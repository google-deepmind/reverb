syntax = "proto3";

package deepmind.reverb;

message PatternNode {
  // Index of the source column in the flattened step structure.
  int32 flat_source_index = 1;

  // Slicing of the source column relative to the most recent step.
  //
  // These fields mimics the behavior of `slice` in Python. That is:
  //
  //  * x[-1:] => (start=-1, stop=null)
  //  * x[-2] => (start=null, stop=-2)
  //  * x[-3:-1] => (start=-3, stop=-1)
  //  * x[-3:-1:2] => (start=-3, stop=-1, step=2)
  //
  // Furthermore, the following requirements applies:
  //
  //  * Slices with undefined `start` (e.g. x[:-2]) are not supported.
  //  * For slices, `start` must be < 0 and `stop` must be <= 0.
  //  * `step` must be > 0 when defined.
  //
  oneof start_or_none {
    int32 start = 2;
  }
  oneof stop_or_none {
    int32 stop = 3;
  }
  oneof step_or_none {
    int32 step = 4;
  }
}

message Condition {
  // Given int32 `left`: `left % mod == eq`.
  message ModuloEq {
    int32 mod = 1;
    int32 eq = 2;
  }

  oneof left {
    // The index of the most recent step within the episode.
    bool step_index = 1;

    // The number of steps since the pattern was most recently applied.
    bool steps_since_applied = 2;

    // The number of steps currently held by the buffer.
    bool buffer_length = 3;

    // Set to 1 when `EndEpisode` is called, else 0.
    bool is_end_episode = 4;
  }

  oneof cmp {
    // `left == eq`.
    int32 eq = 5;

    // `left >= ge`.
    int32 ge = 6;

    // `left <= le`
    int32 le = 7;

    // `left % mod_eq.mod == mod_eq.eq`.
    ModuloEq mod_eq = 8;
  }
}

message StructuredWriterConfig {
  // Flattened output structure.
  repeated PatternNode flat = 1;

  // The table that generated trajectories will be inserted into.
  string table = 2;

  // The priority assigned to all trajectories generated by this config.
  double priority = 3;

  // Conditions which must be fulfilled for the configuration to be applied at
  // the current step.
  repeated Condition conditions = 4;
}
